{"version":3,"sources":["assets/js/markdown-to-html.js"],"names":["exports","output","BLOCK","parseMap","pattern","replace","type","parse","string","forEach","p","matchList","replacement","i","hasOwnProperty","split","join","length","trim","call","arguments","clean","match","rule","module","window","MarkdownToHtml"],"mappings":";CAAC,WAAc,aAEf,IAeCA,EAVAC,EAAS,GAETC,EAAQ,QAgBRC,EAAW,CACV,CAGCC,QAAS,oBACTC,QAAS,kBACTC,KAAMJ,GAEP,CAICE,QAAS,wDACTC,QAAS,YACTC,KAAMJ,GAEP,CAGCE,QAAS,wBACTC,QAAS,qCACTC,KAAMJ,GAEP,CAGCE,QAAS,kBACTC,QAAS,6BACTC,KAAMJ,GAEP,CAGCE,QAAS,wBACTC,QAAS,6BACTC,KAAMJ,GAEP,CAICE,QAAS,oBACTC,QAAS,sBACTC,KA1DO,UA4DR,CAICF,QAAS,iBACTC,QAAS,cACTC,KAlEO,UAoER,CAKCF,QAAS,kCACTC,QAAS,wBACTC,KA3EO,UA6ER,CAKCF,QAAS,6BACTC,QAAS,4BACTC,KApFO,UAsFR,CAGCF,QAAS,iBACTC,QAAS,gBACTC,KA3FO,UA6FR,CAGCF,QAAS,WACTC,QAAS,kBACTC,KAlGO,UAoGR,CAGCF,QAAS,aACTC,QAAS,SACTC,KAAMJ,IA8BAK,SAAAA,EAAMC,GAmBPP,OAjBPA,EAAS,KAAOO,EAAS,KAEzBL,EAASM,QAAQ,SAASC,GAGzBT,EAASA,EAAOI,QAAQK,EAAEN,QAAS,WAE3BC,OAaDA,SAAQM,EAAWC,EAAaN,GAEvCO,IAAAA,EAGGA,IAAAA,KAAKF,EACJA,EAAUG,eAAeD,KAO7BD,GAFAA,EAAcA,EAAYG,MAAM,IAAMF,GAAGG,KAAKL,EAAUE,KAE9BE,MAAM,KAAOF,GAAGG,KAAKL,EAAUE,GAAGI,SAG1DX,IAASJ,IACXU,EAAcA,EAAYM,OAAS,MAG7BN,OAAAA,GAjCUO,KAAK,KAAMC,UAAWV,EAAEL,QAASK,EAAEJ,UASpDL,GAFAA,GAFAA,EA+BQoB,SAAMb,GAgBPA,MAfiB,CACvB,CACCc,MAAO,sBACPV,YAAa,IAEd,CACCU,MAAO,oCACPV,YAAa,OAIGH,QAAQ,SAASc,GAClCf,EAASA,EAAOH,QAAQkB,EAAKD,MAAOC,EAAKX,eAGnCJ,EA/CEa,CAAMpB,IAECiB,QAEAb,QAAQ,YAAa,MArChB,oBAAXmB,aACmB,IAAnBA,OAAOxB,QAChBA,EAAUwB,OAAOxB,QAGQ,oBAAXyB,SACdA,OAAOC,eAAiB,GACxB1B,EAAUyB,OAAOC,gBAGlB1B,EAAQO,MAAQA,EAxIhB","file":"markdown-to-html.b7d7ff9c.js","sourceRoot":"..","sourcesContent":[";(function() { \"use strict\";\n\nvar\n\t/**\n\t * The parsed output string, in HTML format.\n\t * @type {String}\n\t */\n\toutput = \"\",\n\n\tBLOCK = \"block\",\n\tINLINE = \"inline\",\n\n\t/**\n\t * Used to attach MarkdownToHtml object to `window` in browser\n\t * context, or as an AMD module where appropriate.\n\t * @type {Object}\n\t */\n\texports,\n\n\t/**\n\t * An array of parse rule descriptor objects. Each object has two keys;\n\t * pattern (the RegExp to match), and replace (the replacement string or\n\t * function to execute).\n\t * @type {Array}\n\t */\n\tparseMap = [\n\t\t{\n\t\t\t// <h1>\n\t\t\t// A line starting with 1-6 hashes.\n\t\t\tpattern: /(#{1,6})([^\\n]+)/g,\n\t\t\treplace: \"<h$L1>$2</h$L1>\",\n\t\t\ttype: BLOCK,\n\t\t},\n\t\t{\n\t\t\t// <p>\n\t\t\t// Any line surrounded by newlines that doesn't start with\n\t\t\t// an HTML tag, asterisk or numeric value with dot following.\n\t\t\tpattern: /\\n(?!<\\/?\\w+>|\\s?\\*|\\s?[0-9]+|>|\\&gt;|-{5,})([^\\n]+)/g,\n\t\t\treplace: \"<p>$1</p>\",\n\t\t\ttype: BLOCK,\n\t\t},\n\t\t{\n\t\t\t// <blockquote>\n\t\t\t// A greater-than character preceding any characters.\n\t\t\tpattern: /\\n(?:&gt;|\\>)\\W*(.*)/g,\n\t\t\treplace: \"<blockquote><p>$1</p></blockquote>\",\n\t\t\ttype: BLOCK,\n\t\t},\n\t\t{\n\t\t\t// <ul>\n\t\t\t//\n\t\t\tpattern: /\\n\\s?\\*\\s*(.*)/g,\n\t\t\treplace: \"<ul>\\n\\t<li>$1</li>\\n</ul>\",\n\t\t\ttype: BLOCK,\n\t\t},\n\t\t{\n\t\t\t// <ol>\n\t\t\t//\n\t\t\tpattern: /\\n\\s?[0-9]+\\.\\s*(.*)/g,\n\t\t\treplace: \"<ol>\\n\\t<li>$1</li>\\n</ol>\",\n\t\t\ttype: BLOCK,\n\t\t},\n\t\t{\n\t\t\t// <strong>\n\t\t\t// Either two asterisks or two underscores, followed by any\n\t\t\t// characters, followed by the same two starting characters.\n\t\t\tpattern: /(\\*\\*|__)(.*?)\\1/g,\n\t\t\treplace: \"<strong>$2</strong>\",\n\t\t\ttype: INLINE,\n\t\t},\n\t\t{\n\t\t\t// <em>\n\t\t\t// Either one asterisk or one underscore, followed by any\n\t\t\t// characters, followed by the starting character.\n\t\t\tpattern: /(\\*|_)(.*?)\\1/g,\n\t\t\treplace: \"<em>$2</em>\",\n\t\t\ttype: INLINE,\n\t\t},\n\t\t{\n\t\t\t// <a>\n\t\t\t// Not starting with an exclamation mark, square brackets\n\t\t\t// surrounding any characters, followed by parenthesis surrounding\n\t\t\t// any characters.\n\t\t\tpattern: /([^!])\\[([^\\[]+)\\]\\(([^\\)]+)\\)/g,\n\t\t\treplace: \"$1<a href=\\\"$3\\\">$2</a>\",\n\t\t\ttype: INLINE,\n\t\t},\n\t\t{\n\t\t\t// <img>\n\t\t\t// Starting with an exclamation mark, then followed by square\n\t\t\t// brackets surrounding any characters, followed by parenthesis\n\t\t\t// surrounding any characters.\n\t\t\tpattern: /!\\[([^\\[]+)\\]\\(([^\\)]+)\\)/g,\n\t\t\treplace: \"<img src=\\\"$2\\\" alt=\\\"$1\\\" />\",\n\t\t\ttype: INLINE,\n\t\t},\n\t\t{\n\t\t\t// <del>\n\t\t\t// Double tilde characters surrounding any characters.\n\t\t\tpattern: /\\~\\~(.*?)\\~\\~/g,\n\t\t\treplace: \"<del>$1</del>\",\n\t\t\ttype: INLINE,\n\t\t},\n\t\t{\n\t\t\t// <code>\n\t\t\t//\n\t\t\tpattern: /`(.*?)`/g,\n\t\t\treplace: \"<code>$1</code>\",\n\t\t\ttype: INLINE,\n\t\t},\n\t\t{\n\t\t\t// <hr>\n\t\t\t//\n\t\t\tpattern: /\\n-{5,}\\n/g,\n\t\t\treplace: \"<hr />\",\n\t\t\ttype: BLOCK,\n\t\t},\n\t],\n$$;\n\n/**\n * Self-executing function to handle exporting the parse function for\n * external use.\n */\n(function go() {\n\t// Export AMD module if possible.\n\tif(typeof module !== \"undefined\"\n\t&& typeof module.exports !== \"undefined\") {\n\t\texports = module.exports;\n\t}\n\t// Otherwise check for browser context.\n\telse if(typeof window !== \"undefined\") {\n\t\twindow.MarkdownToHtml = {};\n\t\texports = window.MarkdownToHtml;\n\t}\n\n\texports.parse = parse;\n})();\n\n/**\n * Parses a provided Markdown string into valid HTML.\n *\n * @param  {string} string Markdown input for transformation\n * @return {string}        Transformed HTML output\n */\nfunction parse(string) {\n\t// Pad with newlines for compatibility.\n\toutput = \"\\n\" + string + \"\\n\";\n\n\tparseMap.forEach(function(p) {\n\t\t// Replace all matches of provided RegExp pattern with either the\n\t\t// replacement string or callback function.\n\t\toutput = output.replace(p.pattern, function() {\n\t\t\t// console.log(this, arguments);\n\t\t\treturn replace.call(this, arguments, p.replace, p.type);\n\t\t});\n\t});\n\n\t// Perform any post-processing required.\n\toutput = clean(output);\n\t// Trim for any spaces or newlines.\n\toutput = output.trim();\n\t// Tidy up newlines to condense where more than 1 occurs back to back.\n\toutput = output.replace(/[\\n]{1,}/g, \"\\n\");\n\treturn output;\n}\n\nfunction replace(matchList, replacement, type) {\n\tvar\n\t\ti,\n\t$$;\n\n\tfor(i in matchList) {\n\t\tif(!matchList.hasOwnProperty(i)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Replace $n with the matching regexp group.\n\t\treplacement = replacement.split(\"$\" + i).join(matchList[i]);\n\t\t// Replace $Ln with the matching regexp group's string length.\n\t\treplacement = replacement.split(\"$L\" + i).join(matchList[i].length);\n\t}\n\n\tif(type === BLOCK) {\n\t\treplacement = replacement.trim() + \"\\n\";\n\t}\n\n\treturn replacement;\n}\n\nfunction clean(string) {\n\tvar cleaningRuleArray = [\n\t\t{\n\t\t\tmatch: /<\\/([uo]l)>\\s*<\\1>/g,\n\t\t\treplacement: \"\",\n\t\t},\n\t\t{\n\t\t\tmatch: /(<\\/\\w+>)<\\/(blockquote)>\\s*<\\2>/g,\n\t\t\treplacement: \"$1\",\n\t\t},\n\t];\n\n\tcleaningRuleArray.forEach(function(rule) {\n\t\tstring = string.replace(rule.match, rule.replacement);\n\t});\n\n\treturn string;\n}\n\n})();"]}